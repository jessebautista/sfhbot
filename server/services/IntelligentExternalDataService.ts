import { createClient, SupabaseClient } from '@supabase/supabase-js'
import { IntelligentQueryReasoner } from './IntelligentQueryReasoner.js'

interface SearchResult {
  results: any[]
  query: string
  reasoning: string
  dataUsed: boolean
  naturalResponse: string
  executionLog: string[]
}

export class IntelligentExternalDataService {
  private externalSupabase: SupabaseClient | null = null
  private reasoner: IntelligentQueryReasoner
  private isAvailable: boolean = false

  constructor() {
    this.reasoner = new IntelligentQueryReasoner()
    this.initializeConnection()
  }

  private async initializeConnection() {
    const supabaseUrl = process.env.EXTERNAL_SUPABASE_URL
    const supabaseKey = process.env.EXTERNAL_SUPABASE_ANON_KEY

    if (!supabaseUrl || !supabaseKey) {
      console.log('‚ö†Ô∏è External database credentials not found - service unavailable')
      this.isAvailable = false
      return
    }

    try {
      this.externalSupabase = createClient(supabaseUrl, supabaseKey)
      
      // Test connection
      const { data, error } = await this.externalSupabase
        .from('pianos')
        .select('*', { count: 'exact', head: true })

      if (error) {
        console.error('External database connection failed:', error.message)
        this.isAvailable = false
      } else {
        console.log('‚úÖ Intelligent external database service initialized')
        this.isAvailable = true
      }
    } catch (error) {
      console.error('Failed to initialize external database:', error)
      this.isAvailable = false
    }
  }

  /**
   * Intelligent search using AI reasoning instead of basic keyword matching
   */
  async intelligentSearch(userQuery: string): Promise<SearchResult> {
    const executionLog: string[] = []
    executionLog.push(`üß† Starting intelligent search for: "${userQuery}"`)

    if (!this.isAvailable || !this.externalSupabase) {
      executionLog.push('‚ùå External database not available - using fallback')
      return {
        results: [],
        query: userQuery,
        reasoning: 'External database service unavailable',
        dataUsed: false,
        naturalResponse: 'I apologize, but I cannot access the external database right now. Please try again later.',
        executionLog
      }
    }

    try {
      // Step 1: Use AI to analyze query and generate execution plan
      const { intent, sqlQueries, executionPlan } = await this.reasoner.processQuery(userQuery)
      executionLog.push(`üéØ Intent: ${intent.type} (${Math.round(intent.confidence * 100)}% confidence)`)
      executionLog.push(`üìã Generated ${sqlQueries.length} targeted queries`)

      // Step 2: Execute the AI-generated queries
      const allResults: any[] = []
      
      for (const sqlQuery of sqlQueries) {
        executionLog.push(`üóÑÔ∏è Executing: ${sqlQuery.table} query - ${sqlQuery.reasoning}`)
        
        try {
          const results = await this.executeIntelligentQuery(sqlQuery.table, sqlQuery, userQuery)
          if (results.length > 0) {
            allResults.push(...results)
            executionLog.push(`‚úÖ Found ${results.length} results from ${sqlQuery.table}`)
          } else {
            executionLog.push(`üì≠ No results from ${sqlQuery.table}`)
          }
        } catch (error) {
          executionLog.push(`‚ùå Error querying ${sqlQuery.table}: ${error}`)
          console.error(`Error executing query on ${sqlQuery.table}:`, error)
        }
      }

      // Step 3: Process results using AI to create natural language response
      const processedResults = await this.reasoner.processResults(allResults, userQuery, intent)
      executionLog.push(`üìù Processed ${allResults.length} results into natural language`)

      return {
        results: allResults,
        query: userQuery,
        reasoning: intent.reasoning,
        dataUsed: processedResults.dataUsed,
        naturalResponse: processedResults.naturalLanguageResponse,
        executionLog
      }

    } catch (error) {
      executionLog.push(`‚ùå Error in intelligent search: ${error}`)
      console.error('Error in intelligent search:', error)
      
      // Fallback to basic search if AI reasoning fails
      return this.fallbackSearch(userQuery, executionLog)
    }
  }

  /**
   * Execute a specific query generated by the AI reasoner
   */
  private async executeIntelligentQuery(table: string, sqlQuery: any, originalQuery: string): Promise<any[]> {
    if (!this.externalSupabase) return []

    switch (table) {
      case 'pianos':
        return this.queryPianos(originalQuery, sqlQuery.reasoning)
      case 'news':
        return this.queryNews(originalQuery, sqlQuery.reasoning)
      case 'piano_activations':
        return this.queryActivations(originalQuery, sqlQuery.reasoning)
      default:
        console.warn(`Unknown table: ${table}`)
        return []
    }
  }

  /**
   * Smart piano search with improved targeting
   */
  private async queryPianos(query: string, reasoning: string): Promise<any[]> {
    if (!this.externalSupabase) return []

    const searchTerm = `%${query.toLowerCase()}%`
    
    try {
      // Use more targeted search based on reasoning
      let supabaseQuery = this.externalSupabase
        .from('pianos')
        .select('*')

      // Apply smart filtering based on the reasoning
      if (reasoning.includes('location') || /\b(in|at|from|near)\s+\w+/i.test(query)) {
        // Location-focused search
        supabaseQuery = supabaseQuery.or(`piano_location.ilike.${searchTerm},piano_title.ilike.${searchTerm}`)
      } else if (reasoning.includes('artist') || query.toLowerCase().includes('artist')) {
        // Artist-focused search  
        supabaseQuery = supabaseQuery.or(`artist_name.ilike.${searchTerm},piano_title.ilike.${searchTerm}`)
      } else {
        // General comprehensive search
        supabaseQuery = supabaseQuery.or(`piano_title.ilike.${searchTerm},artist_name.ilike.${searchTerm},piano_statement.ilike.${searchTerm}`)
      }

      const { data, error } = await supabaseQuery.limit(15)

      if (error) {
        console.error('Error querying pianos:', error)
        return []
      }

      return data || []
    } catch (error) {
      console.error('Exception in queryPianos:', error)
      return []
    }
  }

  /**
   * Smart news search with improved targeting
   */
  private async queryNews(query: string, reasoning: string): Promise<any[]> {
    if (!this.externalSupabase) return []

    const searchTerm = `%${query.toLowerCase()}%`
    
    try {
      let supabaseQuery = this.externalSupabase
        .from('news')
        .select('*')

      // Apply smart filtering based on reasoning
      if (reasoning.includes('recent') || reasoning.includes('latest')) {
        // Time-focused search - prioritize by ID or date if available
        supabaseQuery = supabaseQuery
          .or(`news_title.ilike.${searchTerm},newscontent.ilike.${searchTerm},news_excerpt.ilike.${searchTerm}`)
          .order('id', { ascending: false })
      } else if (reasoning.includes('category')) {
        // Category-focused search
        supabaseQuery = supabaseQuery.or(`news_categories.ilike.${searchTerm},news_title.ilike.${searchTerm}`)
      } else {
        // General comprehensive search
        supabaseQuery = supabaseQuery.or(`news_title.ilike.${searchTerm},newscontent.ilike.${searchTerm},news_excerpt.ilike.${searchTerm}`)
      }

      const { data, error } = await supabaseQuery.limit(10)

      if (error) {
        console.error('Error querying news:', error)
        return []
      }

      return data || []
    } catch (error) {
      console.error('Exception in queryNews:', error)
      return []
    }
  }

  /**
   * Smart piano activations search
   */
  private async queryActivations(query: string, reasoning: string): Promise<any[]> {
    if (!this.externalSupabase) return []

    const searchTerm = `%${query.toLowerCase()}%`
    
    try {
      let supabaseQuery = this.externalSupabase
        .from('piano_activations')
        .select('*')

      // Apply smart filtering
      if (reasoning.includes('location') || /\b(in|at|from|near)\s+\w+/i.test(query)) {
        supabaseQuery = supabaseQuery.or(`act_location.ilike.${searchTerm},act_title.ilike.${searchTerm}`)
      } else if (reasoning.includes('artist')) {
        supabaseQuery = supabaseQuery.or(`act_artists.ilike.${searchTerm},act_title.ilike.${searchTerm}`)
      } else {
        supabaseQuery = supabaseQuery.or(`act_title.ilike.${searchTerm},act_content.ilike.${searchTerm},act_artists.ilike.${searchTerm}`)
      }

      const { data, error } = await supabaseQuery.limit(10)

      if (error) {
        console.error('Error querying activations:', error)
        return []
      }

      return data || []
    } catch (error) {
      console.error('Exception in queryActivations:', error)
      return []
    }
  }

  /**
   * Fallback search when AI reasoning fails
   */
  private async fallbackSearch(userQuery: string, executionLog: string[]): Promise<SearchResult> {
    executionLog.push('üîÑ Using fallback basic search due to AI reasoning failure')
    
    if (!this.externalSupabase) {
      return {
        results: [],
        query: userQuery,
        reasoning: 'Database unavailable and AI reasoning failed',
        dataUsed: false,
        naturalResponse: 'I encountered technical difficulties accessing the database. Please try again.',
        executionLog
      }
    }

    try {
      // Simple multi-table search
      const [pianos, news, activations] = await Promise.all([
        this.queryPianos(userQuery, 'fallback search'),
        this.queryNews(userQuery, 'fallback search'), 
        this.queryActivations(userQuery, 'fallback search')
      ])

      const allResults = [...pianos, ...news, ...activations]
      executionLog.push(`üîÑ Fallback found ${allResults.length} total results`)

      return {
        results: allResults,
        query: userQuery,
        reasoning: 'Fallback keyword-based search across all tables',
        dataUsed: allResults.length > 0,
        naturalResponse: this.createFallbackResponse(allResults, userQuery),
        executionLog
      }
    } catch (error) {
      executionLog.push(`‚ùå Fallback search also failed: ${error}`)
      return {
        results: [],
        query: userQuery,
        reasoning: 'Both intelligent and fallback searches failed',
        dataUsed: false,
        naturalResponse: 'I encountered technical difficulties searching our database. Please try again later.',
        executionLog
      }
    }
  }

  private createFallbackResponse(results: any[], query: string): string {
    if (results.length === 0) {
      return `I searched our database for "${query}" but couldn't find any matching records. Could you try rephrasing your question?`
    }

    const pianos = results.filter(r => r.piano_title)
    const news = results.filter(r => r.news_title)
    const activations = results.filter(r => r.act_title)

    let response = `I found ${results.length} result${results.length > 1 ? 's' : ''} for "${query}": `

    const parts = []
    if (pianos.length > 0) parts.push(`${pianos.length} piano${pianos.length > 1 ? 's' : ''}`)
    if (news.length > 0) parts.push(`${news.length} news article${news.length > 1 ? 's' : ''}`)
    if (activations.length > 0) parts.push(`${activations.length} activation${activations.length > 1 ? 's' : ''}`)

    response += parts.join(', ') + '.'

    // Add a specific example if available
    const firstResult = results[0]
    if (firstResult.piano_title) {
      response += ` For example: "${firstResult.piano_title}"`
    } else if (firstResult.news_title) {
      response += ` For example: "${firstResult.news_title}"`
    } else if (firstResult.act_title) {
      response += ` For example: "${firstResult.act_title}"`
    }

    return response
  }

  /**
   * Get service status
   */
  getStatus() {
    return {
      available: this.isAvailable,
      hasConnection: this.externalSupabase !== null,
      reasonerLoaded: this.reasoner !== null
    }
  }
}